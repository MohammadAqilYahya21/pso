# -*- coding: utf-8 -*-
"""PSO v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D03TTbOazK6sAxXXQ2-ngj_0wfdCb1et

# meta - PSO

This modified code implements PSO for the multiple knapsack problem. Here are the key changes and additions:

A new Particle class is introduced to represent each particle in the swarm.
The particle_swarm_optimization function replaces the simulated_annealing function. It initializes a swarm of particles and iteratively updates their positions and velocities.
Each particle's position is represented as a list of integers, where each integer corresponds to the knapsack index for each item. A value equal to the number of knapsacks means the item is not selected.
The particle's velocity is used to update its position, with cognitive and social components influencing the movement.
The global best solution is tracked and updated throughout the iterations.
The main PSO parameters (w, c1, c2) are set to common values, but you may want to tune these for your specific problem.
The main function now calls particle_swarm_optimization instead of simulated_annealing.

This PSO implementation should provide good results for the multiple knapsack problem, potentially exploring the solution space more effectively than the previous Simulated Annealing approach. You may need to adjust the number of particles and iterations to balance between solution quality and computation time.
"""

import random
import math
import pandas as pd
import numpy as np

# Item and Knapsack classes remain the same

# Define the problem function remains the same

# Particle class for PSO
class Particle:
    def __init__(self, items, knapsacks):
        self.position = [random.choice(range(len(knapsacks) + 1)) for _ in items]
        self.velocity = [random.uniform(-1, 1) for _ in items]
        self.best_position = self.position[:]
        self.best_value = self.evaluate(items, knapsacks)

    def evaluate(self, items, knapsacks):
        solution = [Knapsack(k.capacity, k.budget) for k in knapsacks]
        for i, knapsack_index in enumerate(self.position):
            if knapsack_index < len(knapsacks):
                solution[knapsack_index].add_item(items[i])
        return sum(k.total_value() for k in solution) if all(k.is_valid() for k in solution) else 0

    def update_velocity(self, global_best_position, w, c1, c2):
        for i in range(len(self.velocity)):
            r1, r2 = random.random(), random.random()
            cognitive = c1 * r1 * (self.best_position[i] - self.position[i])
            social = c2 * r2 * (global_best_position[i] - self.position[i])
            self.velocity[i] = w * self.velocity[i] + cognitive + social

    def update_position(self, num_knapsacks):
        for i in range(len(self.position)):
            self.position[i] = max(0, min(num_knapsacks, round(self.position[i] + self.velocity[i])))

# PSO algorithm
def particle_swarm_optimization(items, knapsacks, num_particles, num_iterations):
    particles = [Particle(items, knapsacks) for _ in range(num_particles)]
    global_best_position = particles[0].position[:]
    global_best_value = particles[0].best_value

    w, c1, c2 = 0.7, 1.4, 1.4  # PSO parameters

    for _ in range(num_iterations):
        for particle in particles:
            value = particle.evaluate(items, knapsacks)
            if value > particle.best_value:
                particle.best_value = value
                particle.best_position = particle.position[:]
            if value > global_best_value:
                global_best_value = value
                global_best_position = particle.position[:]

        for particle in particles:
            particle.update_velocity(global_best_position, w, c1, c2)
            particle.update_position(len(knapsacks))

    # Convert the best position to a solution
    best_solution = [Knapsack(k.capacity, k.budget) for k in knapsacks]
    for i, knapsack_index in enumerate(global_best_position):
        if knapsack_index < len(knapsacks):
            best_solution[knapsack_index].add_item(items[i])

    return best_solution, global_best_value

class Item:
    def __init__(self, category, name, price, weight, value):
        self.category = category
        self.name = name
        self.price = price
        self.weight = weight
        self.value = value

class Knapsack:
    def __init__(self, capacity, budget):
        self.capacity = capacity
        self.budget = budget
        self.items = []

    def add_item(self, item):
        if self.can_add_item(item):
            self.items.append(item)

    def can_add_item(self, item):
        return self.total_weight() + item.weight <= self.capacity and self.total_price() + item.price <= self.budget

    def total_weight(self):
        return sum(item.weight for item in self.items)

    def total_price(self):
        return sum(item.price for item in self.items)

    def total_value(self):
        return sum(item.value for item in self.items)

    def is_valid(self):
        return self.total_weight() <= self.capacity and self.total_price() <= self.budget


# The evaluate_solution function remains the same

#ganti
def create_problem(dataset_csv,bin_csv):
    # Read items from CSV file
    items_df = pd.read_csv(dataset_csv)
    items = [Item(row['Category'], row['Name'], row['Price'], row['Weight'], row['Value']) for _, row in items_df.iterrows()]


    # Read knapsacks from CSV file
    knapsacks_df = pd.read_csv(bin_csv)
    knapsacks = [Knapsack(row['capacity'], row['budget']) for _, row in knapsacks_df.iterrows()]


    return items, knapsacks

def evaluate_solution(solution, knapsacks):
    total_value = 0
    all_constraints_met = True

    for i, knapsack in enumerate(solution):
        original_knapsack = knapsacks[i]
        total_weight = knapsack.total_weight()
        total_price = knapsack.total_price()
        knapsack_value = knapsack.total_value()

        total_value += knapsack_value

        if total_weight > original_knapsack.capacity:
            print(f"Constraint violated: Knapsack {i+1} weight ({total_weight}) exceeds capacity ({original_knapsack.capacity})")
            all_constraints_met = False

        if total_price > original_knapsack.budget:
            print(f"Constraint violated: Knapsack {i+1} price ({total_price}) exceeds budget ({original_knapsack.budget})")
            all_constraints_met = False

    return total_value, all_constraints_met


def main():
  #ganti
    dataset_csv = 'product_data.csv'
    bin_csv = 'bin.csv'
    items, knapsacks = create_problem(dataset_csv, bin_csv)

    num_particles = 50
    num_iterations = 1000

    best_solution, best_value = particle_swarm_optimization(items, knapsacks, num_particles, num_iterations)

    print(f"Best value found: {best_value}")
    for i, knapsack in enumerate(best_solution):
        print(f"\nKnapsack {i+1}:")
        print(f"Total weight: {knapsack.total_weight():.2f}/{knapsack.capacity}")
        print(f"Total price: {knapsack.total_price():.2f}/{knapsack.budget}")
        print("Items:")
        for item in knapsack.items:
            print(f"  {item.category} - {item.name}: weight={item.weight:.2f}, value={item.value:.2f}, price={item.price:.2f}")

    print("\nEvaluating solution:")
    total_value, all_constraints_met = evaluate_solution(best_solution, knapsacks)
    print(f"Total value: {total_value:.2f}")
    print(f"All constraints met: {'Yes' if all_constraints_met else 'No'}")

if __name__ == "__main__":
    main()